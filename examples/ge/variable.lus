include "library/variable_check.lus"

(* S is true iff X has been true at some point previously and Y
   has been true ever since (or if X is true in the current timestep) *)
node Since(X, Y: bool) returns (S : bool);
let
  S =  X or (Y and (false -> pre S));
tel

(* Y is true iff X has been true at some point previously or in the current timestep *)
node Once(X: bool) returns (Y: bool);
let
  Y = X or (false -> pre Y);
tel

(* Y is true iff X has been true at every time step, including the current timestep *)
node Sofar( X : bool ) returns ( Y : bool );
let
  Y = X -> (X and pre Y);
tel

node Initially (x: bool) returns (y: bool);
let
  y = x -> pre y;
tel

(* Y is true iff X is true now but wasn't true in the previous timestep *)
node Rise( X : bool ) returns ( Y : bool );
let
  Y = X -> (X and not pre X);
tel

(* Y is true iff X is false now but was true in the previous timestep *)
node Fall( X : bool ) returns ( Y : bool );
let
  Y = false -> (not X and pre X);
tel

(* Y is equal to the number of times X has been true so far *)
node Count( X: bool ) returns (Y: int );
let
  Y = (if X then 1 else 0) -> (if X then pre Y + 1 else pre Y);
tel

(* Predicate to determine whether "in" is a well-formed example *)
node imported IsGoodVariable(in: int64) returns (out: bool);
(*@contract
  guarantee true;
*)

(* Node specifying the Master process's behavior *)
node imported Master(TREADY: bool) returns (TVALID, transfer: bool; TDATA: int64; TLAST: bool);
(*@contract 
  (* For a transfer to occur, both TVALID and TREADY must be asserted *)
  guarantee transfer => (TREADY and TVALID);

  (* A master is not permitted to wait until TREADY is asserted before asserting TVALID *)
  (* My interpretation-- the master should not be restricted to only waiting until after TREADY before
     asserting TVALID *)

  (* Once TVALID is asserted it must remain asserted until the handshake occurs *)
  (* If Master is not transferring data, TVALID must fall *)
  guarantee Fall(TVALID) => Fall(transfer);
*)

(* Node specifying the Slave process's behavior *)
node imported Slave(TVALID, transfer: bool; TDATA: int64; TLAST: bool) returns (TREADY: bool; isFoul, isBad, isGood, isReady: bool; success, error: bool);
(* A slave is permitted to wait for TVALID to be asserted before asserting the corresponding TREADY *)
(* If a slave asserts TREADY, it is permitted to deassert TREADY before TVALID is asserted *)
(*@contract
  (* Checks on TDATA *)
  guarantee VariableCheck(TVALID, transfer, TDATA, TLAST, TREADY, success, error, isFoul, isBad, isGood, isReady);
*)

(* Top-level node with system-level properties *)
node Main(RESET: bool) returns (TREADY, TVALID, transfer, TLAST: bool; TDATA: int64; isFoul, isBad, isGood, isReady: bool; success, error: bool; P1, P2: bool);
let
  (TVALID, transfer, TDATA, TLAST) = Master(TREADY);
  (TREADY, isFoul, isBad, isGood, isReady, success, error) = Slave(TVALID, transfer, TDATA, TLAST);

  P1 = (Initially(RESET) and 
        Fall(transfer) and 
        (false -> pre (false -> pre Rise(transfer))) and 
        (false -> pre (false -> pre (TDATA = int64 2))) and
        (false -> pre TLAST) 
       ) => isGood;
  P2 = (Initially(RESET) and 
        Fall(transfer) and 
        (false -> pre (false -> pre Rise(transfer))) and 
        (false -> pre (false -> pre (TDATA = int64 1))) and 
        (false -> pre TLAST)  
       ) => isBad;

  check P1;
  check P2;
  --%MAIN;
tel